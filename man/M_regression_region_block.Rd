% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{M_regression_region_block}
\alias{M_regression_region_block}
\title{Image on scalar regression}
\usage{
M_regression_region_block(
  M,
  X,
  C,
  L_all,
  num_region,
  region_idx,
  n_mcmc,
  K,
  stop_burnin,
  lambda,
  target_accept_vec,
  init,
  interval,
  step,
  a = 1,
  b = 1,
  interval_eta = 10L,
  thinning = 10L,
  display_progress = TRUE
)
}
\arguments{
\item{M}{The image predictor, n by p}

\item{X}{The scalar exposure variable, n by 1}

\item{C}{The q confounders, n by q}

\item{L_all}{A vector of length num_region, each element is an integer to indicate the number of basis in each region}

\item{num_region}{An integer, the total number of regions}

\item{region_idx}{A list object of length num_region, each element is a vector of
the indices of each voxel in that region. Note that this index starts from 0.}

\item{n_mcmc}{An integer to indicate the total number of MCMC iterations}

\item{K}{A list object of length num_region, the r-th element is a p_r by L_r matrix for the basis function}

\item{stop_burnin}{An integer to indicate from which iteration to stop burnin period.
Note that during burinin, the step size in MALA is adjusted every interval_step iterations.}

\item{lambda}{A numeric variable to indicate the thresholding parameter lambda in STGP prior}

\item{target_accept_vec}{A vector of length num_region. Each element is a numeric variable in (0,1).
This allows the user to define different target acceptance rate for each region in the MALA algorithm,
and the step size will be adjusted to meet the target acceptance rate.}

\item{init}{A list object that contains the following element
\itemize{
  \item theta_alpha A vector of length L. Initial value for theta_beta
  \item theta_zetam A L by q matrix. Initial value for theta_zetam
  \item theta_eta A matrix (L by n). Initial value for theta_eta
  \item D A vector of length L. Eigenvalues for all regions in the basis
  \item sigma_M A numeric scalar, initial value for gamma
  \item zetay A vector of length q, intial value for zetay
  \item sigma_alpha A numeric scalar, intial value for sigma_alpha
  \item sigma_eta A numeric scalar, initial value for sigma_eta
}}

\item{interval}{An integer to denote how often to update the step size}

\item{step}{A numeric vector of length num_region, the initial step size for each region}

\item{a}{A numeric variable for the Inverse-Gamma(a,b), priors for \eqn{\sigma^2_Y,\sigma^2_\beta}}

\item{b}{A numeric variable for the Inverse-Gamma(a,b), priors for \eqn{\sigma^2_Y,\sigma^2_\beta}}

\item{interval_eta}{An integer to denote how often to update theta_eta}

\item{thinning}{An integer to indicate how often to save the MCMC samples for theta_alpha}

\item{display_progress}{True for displaying progress bar}
}
\value{
A List object with the following component
\itemize{
\item theta_alpha_mcmc
\item logll_mcmc
\item track_step
\item accept_block
\item emp_accept
\item gs A list object with the following component
  \itemize{
    \item theta_zetam_mcmc
    \item sigma_M2_inv_mcmc
    \item sigma_alpha2_inv_mcmc
    \item sigma_eta2_inv_mcmc
  }
\item Timer
}
}
\description{
A basis decomposition is used. The main coefficient alpha follows STGP prior.
Kernel matrices need to be pre-speficified
}
